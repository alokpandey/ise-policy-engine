package com.cisco.ise.ai.simulator.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * Represents a network event generated by the simulator
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NetworkEvent {
    
    private String eventId;
    private String deviceId;
    private EventType eventType;
    private EventSeverity severity;
    private String title;
    private String description;
    private LocalDateTime timestamp;
    private String source;
    private String destination;
    private Map<String, Object> eventData;
    private boolean resolved;
    private String resolution;
    
    public enum EventType {
        // Connection Events
        DEVICE_CONNECTED("Device Connected"),
        DEVICE_DISCONNECTED("Device Disconnected"),
        AUTHENTICATION_SUCCESS("Authentication Success"),
        AUTHENTICATION_FAILURE("Authentication Failure"),
        
        // Security Events
        SUSPICIOUS_ACTIVITY("Suspicious Activity"),
        MALWARE_DETECTED("Malware Detected"),
        UNAUTHORIZED_ACCESS_ATTEMPT("Unauthorized Access Attempt"),
        POLICY_VIOLATION("Policy Violation"),
        ANOMALOUS_BEHAVIOR("Anomalous Behavior"),
        
        // Network Events
        BANDWIDTH_THRESHOLD_EXCEEDED("Bandwidth Threshold Exceeded"),
        UNUSUAL_TRAFFIC_PATTERN("Unusual Traffic Pattern"),
        PORT_SCAN_DETECTED("Port Scan Detected"),
        DNS_TUNNELING("DNS Tunneling"),
        
        // Compliance Events
        COMPLIANCE_VIOLATION("Compliance Violation"),
        POSTURE_ASSESSMENT_FAILED("Posture Assessment Failed"),
        CERTIFICATE_EXPIRED("Certificate Expired"),
        OUTDATED_SOFTWARE("Outdated Software"),
        
        // IoT Events
        IOT_DEVICE_ANOMALY("IoT Device Anomaly"),
        IOT_COMMUNICATION_PATTERN("IoT Communication Pattern"),
        IOT_FIRMWARE_OUTDATED("IoT Firmware Outdated"),
        
        // Administrative Events
        POLICY_APPLIED("Policy Applied"),
        QUARANTINE_APPLIED("Quarantine Applied"),
        ACCESS_GRANTED("Access Granted"),
        ACCESS_DENIED("Access Denied");
        
        private final String displayName;
        
        EventType(String displayName) {
            this.displayName = displayName;
        }
        
        public String getDisplayName() {
            return displayName;
        }
    }
    
    public enum EventSeverity {
        LOW(1, "Low", "Informational event"),
        MEDIUM(2, "Medium", "Warning event requiring attention"),
        HIGH(3, "High", "Critical event requiring immediate action"),
        CRITICAL(4, "Critical", "Emergency event requiring urgent response");
        
        private final int level;
        private final String displayName;
        private final String description;
        
        EventSeverity(int level, String displayName, String description) {
            this.level = level;
            this.displayName = displayName;
            this.description = description;
        }
        
        public int getLevel() { return level; }
        public String getDisplayName() { return displayName; }
        public String getDescription() { return description; }
        
        public boolean isHighSeverity() {
            return this == HIGH || this == CRITICAL;
        }
    }
    
    /**
     * Checks if this event indicates a security threat
     */
    public boolean isSecurityEvent() {
        return eventType == EventType.SUSPICIOUS_ACTIVITY ||
               eventType == EventType.MALWARE_DETECTED ||
               eventType == EventType.UNAUTHORIZED_ACCESS_ATTEMPT ||
               eventType == EventType.ANOMALOUS_BEHAVIOR ||
               eventType == EventType.PORT_SCAN_DETECTED ||
               eventType == EventType.DNS_TUNNELING;
    }
    
    /**
     * Checks if this event requires immediate attention
     */
    public boolean requiresImmediateAttention() {
        return severity.isHighSeverity() || isSecurityEvent();
    }
    
    /**
     * Gets a formatted event summary
     */
    public String getEventSummary() {
        return String.format("[%s] %s - %s", 
                           severity.getDisplayName(), 
                           eventType.getDisplayName(), 
                           title);
    }
    
    /**
     * Calculates event priority score for sorting
     */
    public int getPriorityScore() {
        int score = severity.getLevel() * 10;
        
        if (isSecurityEvent()) {
            score += 20;
        }
        
        if (!resolved) {
            score += 10;
        }
        
        // Recent events get higher priority
        long hoursAgo = java.time.temporal.ChronoUnit.HOURS.between(timestamp, LocalDateTime.now());
        if (hoursAgo < 1) {
            score += 15;
        } else if (hoursAgo < 24) {
            score += 5;
        }
        
        return score;
    }
    
    /**
     * Marks the event as resolved with a resolution description
     */
    public void resolve(String resolutionDescription) {
        this.resolved = true;
        this.resolution = resolutionDescription;
    }
    
    /**
     * Gets the age of the event in hours
     */
    public long getAgeInHours() {
        return java.time.temporal.ChronoUnit.HOURS.between(timestamp, LocalDateTime.now());
    }
    
    /**
     * Checks if the event is recent (within last hour)
     */
    public boolean isRecent() {
        return getAgeInHours() < 1;
    }
}
